<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kindle Screensaver Converter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        
        .header h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        .header p {
            color: #7f8c8d;
            font-size: 1.1rem;
            margin-bottom: 20px;
        }
        
        .device-selector {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .device-selector select, .custom-dimensions {
            padding: 12px 20px;
            border: 2px solid #e0e6ed;
            border-radius: 12px;
            font-size: 1rem;
            background: white;
            color: #2c3e50;
            transition: all 0.3s ease;
        }
        
        .device-selector select:focus, .custom-dimensions:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .custom-dimensions {
            width: 120px;
            text-align: center;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        
        .panel h2 {
            color: #2c3e50;
            font-size: 1.5rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .upload-area {
            border: 3px dashed #bdc3c7;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
            position: relative;
        }
        
        .upload-area:hover, .upload-area.dragover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
            transform: translateY(-2px);
        }
        
        .upload-icon {
            font-size: 3rem;
            color: #bdc3c7;
            margin-bottom: 15px;
        }
        
        .upload-area.dragover .upload-icon {
            color: #667eea;
        }
        
        #fileInput {
            display: none;
        }
        
        .canvas-container {
            position: relative;
            border: 2px solid #e0e6ed;
            border-radius: 12px;
            background: #f8f9fa;
            max-height: 500px;
            overflow: auto;
            margin-bottom: 20px;
        }
        
        #canvas {
            display: block;
            max-width: 100%;
            cursor: crosshair;
        }
        
        .crop-info {
            background: rgba(52, 73, 94, 0.9);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9rem;
            margin-top: 10px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .control-group label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.95rem;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #e0e6ed;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            border: none;
        }
        
        .slider-value {
            min-width: 45px;
            text-align: right;
            font-weight: 600;
            color: #667eea;
        }
        
        .preview-container {
            background: #34495e;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        #previewCanvas {
            max-width: 100%;
            max-height: 250px;
            border: 2px solid #95a5a6;
            border-radius: 8px;
            background: white;
        }
        
        .preview-info {
            color: white;
            margin-top: 15px;
            font-size: 0.9rem;
        }
        
        .buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .btn {
            padding: 15px 25px;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-secondary {
            background: #95a5a6;
            color: white;
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .status-bar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px 25px;
            text-align: center;
            font-weight: 500;
            color: #2c3e50;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #2ecc71;
            color: white;
            padding: 15px 25px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
        }
        
        .toast.show {
            transform: translateX(0);
        }
        
        .toast.error {
            background: #e74c3c;
        }
        
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .device-selector {
                flex-direction: column;
                gap: 10px;
            }
        }
        
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .buttons {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 id="mainTitle">Kindle Screensaver Converter</h1>
            <p id="mainSubtitle">Convert your images to perfect Kindle screensavers</p>
            
            <div class="device-selector">
                <label for="kindleModel" id="selectDeviceLabel">Select your Kindle:</label>
                <select id="kindleModel">
                    <option value="custom" data-name="Custom">Custom Size</option>
                    <option value="k1" data-name="Kindle 1st Gen (K1)">Kindle 1st Gen (K1) - 600√ó800</option>
                    <option value="k2" data-name="Kindle 2 (K2/K2i)">Kindle 2 (K2/K2i) - 600√ó800</option>
                    <option value="dx" data-name="Kindle DX (DX/DXG)">Kindle DX (DX/DXG) - 824√ó1200</option>
                    <option value="k3" data-name="Kindle Keyboard (K3)">Kindle Keyboard (K3) - 600√ó800</option>
                    <option value="k4" data-name="Kindle 4 (K4S/K4B)">Kindle 4 (K4S/K4B) - 600√ó800</option>
                    <option value="kt" data-name="Kindle Touch (KT/K5)">Kindle Touch (KT/K5) - 600√ó800</option>
                    <option value="pw1" data-name="Paperwhite 1st Gen (PW1)">Paperwhite 1st Gen (PW1) - 758√ó1024</option>
                    <option value="pw2" data-name="Paperwhite 2nd Gen (PW2)">Paperwhite 2nd Gen (PW2) - 758√ó1024</option>
                    <option value="kt2" data-name="Kindle 7th Gen (KT2)">Kindle 7th Gen (KT2) - 600√ó800</option>
                    <option value="kv" data-name="Kindle Voyage (KV)">Kindle Voyage (KV) - 1072√ó1448</option>
                    <option value="pw3" data-name="Paperwhite 3rd Gen (PW3)" selected>Paperwhite 3rd Gen (PW3) - 1072√ó1448</option>
                    <option value="koa" data-name="Oasis 1st Gen (KOA)">Oasis 1st Gen (KOA) - 1080√ó1440</option>
                    <option value="kt3" data-name="Kindle 8th Gen (KT3)">Kindle 8th Gen (KT3) - 600√ó800</option>
                    <option value="koa2" data-name="Oasis 2nd Gen (KOA2)">Oasis 2nd Gen (KOA2) - 1264√ó1680</option>
                    <option value="pw4" data-name="Paperwhite 4th Gen (PW4)">Paperwhite 4th Gen (PW4) - 1072√ó1448</option>
                    <option value="kt4" data-name="Kindle 10th Gen (KT4)">Kindle 10th Gen (KT4) - 600√ó800</option>
                    <option value="koa3" data-name="Oasis 3rd Gen (KOA3)">Oasis 3rd Gen (KOA3) - 1264√ó1680</option>
                    <option value="pw5" data-name="Paperwhite 5th Gen (PW5)">Paperwhite 5th Gen (PW5) - 1236√ó1648</option>
                    <option value="kt5" data-name="Kindle 11th Gen (KT5)">Kindle 11th Gen (KT5) - 1072√ó1448</option>
                    <option value="ks" data-name="Kindle Scribe (KS)">Kindle Scribe (KS) - 1860√ó2480</option>
                </select>
                
                <div id="customSizeInputs" style="display: none; gap: 10px;">
                    <input type="number" id="customWidth" class="custom-dimensions" placeholder="Width" min="100" max="5000">
                    <span>√ó</span>
                    <input type="number" id="customHeight" class="custom-dimensions" placeholder="Height" min="100" max="5000">
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="panel">
                <h2 id="originalImageTitle">üñºÔ∏è Original Image</h2>
                
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">üìÅ</div>
                    <h3 id="uploadTitle">Drop your image here or click to select</h3>
                    <p id="uploadSubtitle">Supports JPG, PNG, WebP, and more</p>
                    <input type="file" id="fileInput" accept="image/*" multiple>
                </div>
                
                <div class="canvas-container">
                    <canvas id="canvas"></canvas>
                </div>
                
                <div class="crop-info" id="cropInfo" style="display: none;">
                    <div id="cropDetails"></div>
                </div>
            </div>
            
            <div class="panel">
                <h2 id="settingsTitle">‚öôÔ∏è Settings & Preview</h2>
                
                <div class="controls">
                    <div class="control-group">
                        <label for="contrastSlider" id="contrastLabel">Contrast:</label>
                        <div class="slider-container">
                            <input type="range" id="contrastSlider" class="slider" min="0.5" max="2.5" step="0.1" value="1.3">
                            <span class="slider-value" id="contrastValue">1.3</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label for="sharpnessSlider" id="sharpnessLabel">Sharpness:</label>
                        <div class="slider-container">
                            <input type="range" id="sharpnessSlider" class="slider" min="0.5" max="2.0" step="0.1" value="1.2">
                            <span class="slider-value" id="sharpnessValue">1.2</span>
                        </div>
                    </div>
                </div>
                
                <div class="preview-container">
                    <canvas id="previewCanvas"></canvas>
                    <div class="preview-info" id="previewInfo">Select an image to start</div>
                </div>
                
                <div class="buttons">
                    <button class="btn btn-secondary" id="resetCropBtn" disabled>
                        üîÑ <span id="resetCropText">Reset Crop</span>
                    </button>
                    <button class="btn btn-primary" id="previewBtn" disabled>
                        üëÅÔ∏è <span id="previewText">Preview</span>
                    </button>
                </div>
                
                <div class="buttons" style="margin-top: 15px;">
                    <button class="btn btn-primary" id="downloadBtn" disabled>
                        üíæ <span id="downloadText">Download</span>
                    </button>
                    <button class="btn btn-secondary" id="batchBtn" disabled>
                        üìä <span id="batchText">Batch Process</span>
                    </button>
                </div>
            </div>
        </div>
        
        <div class="status-bar" id="statusBar">Ready to convert your images</div>
    </div>

    <script>
        // Device configurations
        const kindleDevices = {
            k1: { width: 600, height: 800, name: 'Kindle 1st Gen (K1)' },
            k2: { width: 600, height: 800, name: 'Kindle 2 (K2/K2i)' },
            dx: { width: 824, height: 1200, name: 'Kindle DX (DX/DXG)' },
            k3: { width: 600, height: 800, name: 'Kindle Keyboard (K3)' },
            k4: { width: 600, height: 800, name: 'Kindle 4 (K4S/K4B)' },
            kt: { width: 600, height: 800, name: 'Kindle Touch (KT/K5)' },
            pw1: { width: 758, height: 1024, name: 'Paperwhite 1st Gen (PW1)' },
            pw2: { width: 758, height: 1024, name: 'Paperwhite 2nd Gen (PW2)' },
            kt2: { width: 600, height: 800, name: 'Kindle 7th Gen (KT2)' },
            kv: { width: 1072, height: 1448, name: 'Kindle Voyage (KV)' },
            pw3: { width: 1072, height: 1448, name: 'Paperwhite 3rd Gen (PW3)' },
            koa: { width: 1080, height: 1440, name: 'Oasis 1st Gen (KOA)' },
            kt3: { width: 600, height: 800, name: 'Kindle 8th Gen (KT3)' },
            koa2: { width: 1264, height: 1680, name: 'Oasis 2nd Gen (KOA2)' },
            pw4: { width: 1072, height: 1448, name: 'Paperwhite 4th Gen (PW4)' },
            kt4: { width: 600, height: 800, name: 'Kindle 10th Gen (KT4)' },
            koa3: { width: 1264, height: 1680, name: 'Oasis 3rd Gen (KOA3)' },
            pw5: { width: 1236, height: 1648, name: 'Paperwhite 5th Gen (PW5)' },
            kt5: { width: 1072, height: 1448, name: 'Kindle 11th Gen (KT5)' },
            ks: { width: 1860, height: 2480, name: 'Kindle Scribe (KS)' }
        };

        // Language detection and texts
        const userLanguage = navigator.language || navigator.userLanguage;
        const isItalian = userLanguage.toLowerCase().startsWith('it');

        const texts = {
            en: {
                mainTitle: 'Kindle Screensaver Converter',
                mainSubtitle: 'Convert your images to perfect Kindle screensavers',
                selectDeviceLabel: 'Select your Kindle:',
                originalImageTitle: 'üñºÔ∏è Original Image',
                uploadTitle: 'Drop your image here or click to select',
                uploadSubtitle: 'Supports JPG, PNG, WebP, and more',
                settingsTitle: '‚öôÔ∏è Settings & Preview',
                contrastLabel: 'Contrast:',
                sharpnessLabel: 'Sharpness:',
                resetCropText: 'Reset Crop',
                previewText: 'Preview',
                downloadText: 'Download',
                batchText: 'Batch Process',
                statusReady: 'Ready to convert your images',
                statusImageLoaded: 'Image loaded - Drag to crop or use preview',
                statusCropSet: 'Crop area selected - Ready to preview',
                statusPreviewReady: 'Preview generated - Ready to download!',
                statusProcessing: 'Processing image...',
                previewSelectImage: 'Select an image to start',
                previewDimensions: 'dimensions',
                previewRatio: 'ratio',
                errorTitle: 'Error',
                errorImageLoad: 'Could not load the image. Please try another file.',
                errorImageProcess: 'Error processing image. Please try again.',
                successTitle: 'Success!',
                successMessage: 'Screensaver image downloaded successfully!',
                cropInstructions: 'Drag to select crop area. Will maintain Kindle proportions.',
                batchProcessing: 'Processing images...',
                batchComplete: 'Batch processing completed!'
            },
            it: {
                mainTitle: 'Convertitore Screensaver Kindle',
                mainSubtitle: 'Converti le tue immagini in screensaver perfetti per Kindle',
                selectDeviceLabel: 'Seleziona il tuo Kindle:',
                originalImageTitle: 'üñºÔ∏è Immagine Originale',
                uploadTitle: 'Trascina qui la tua immagine o clicca per selezionare',
                uploadSubtitle: 'Supporta JPG, PNG, WebP e altro',
                settingsTitle: '‚öôÔ∏è Impostazioni e Anteprima',
                contrastLabel: 'Contrasto:',
                sharpnessLabel: 'Nitidezza:',
                resetCropText: 'Reset Crop',
                previewText: 'Anteprima',
                downloadText: 'Scarica',
                batchText: 'Batch',
                statusReady: 'Pronto per convertire le tue immagini',
                statusImageLoaded: 'Immagine caricata - Trascina per ritagliare o usa anteprima',
                statusCropSet: 'Area di ritaglio selezionata - Pronto per anteprima',
                statusPreviewReady: 'Anteprima generata - Pronta per il download!',
                statusProcessing: 'Elaborando immagine...',
                previewSelectImage: 'Seleziona un\'immagine per iniziare',
                previewDimensions: 'dimensioni',
                previewRatio: 'rapporto',
                errorTitle: 'Errore',
                errorImageLoad: 'Impossibile caricare l\'immagine. Prova un altro file.',
                errorImageProcess: 'Errore nell\'elaborazione dell\'immagine. Riprova.',
                successTitle: 'Successo!',
                successMessage: 'Immagine screensaver scaricata con successo!',
                cropInstructions: 'Trascina per selezionare area di ritaglio. Manterr√† le proporzioni Kindle.',
                batchProcessing: 'Elaborando immagini...',
                batchComplete: 'Elaborazione batch completata!'
            }
        };

        const currentTexts = isItalian ? texts.it : texts.en;

        // Global variables
        let originalImage = null;
        let canvas = null;
        let ctx = null;
        let previewCanvas = null;
        let previewCtx = null;
        let cropArea = { x: 0, y: 0, width: 0, height: 0 };
        let isDragging = false;
        let startX = 0;
        let startY = 0;
        let currentKindleSize = kindleDevices.pw3;
        let imageScale = 1;
        let imageOffset = { x: 0, y: 0 };

        // Initialize application
        function init() {
            // Apply language texts
            applyLanguageTexts();
            
            // Get DOM elements
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            previewCanvas = document.getElementById('previewCanvas');
            previewCtx = previewCanvas.getContext('2d');
            
            // Event listeners
            setupEventListeners();
            
            // Set initial Kindle device
            updateKindleDevice();
            
            updateStatus(currentTexts.statusReady);
        }

        function applyLanguageTexts() {
            document.getElementById('mainTitle').textContent = currentTexts.mainTitle;
            document.getElementById('mainSubtitle').textContent = currentTexts.mainSubtitle;
            document.getElementById('selectDeviceLabel').textContent = currentTexts.selectDeviceLabel;
            document.getElementById('originalImageTitle').textContent = currentTexts.originalImageTitle;
            document.getElementById('uploadTitle').textContent = currentTexts.uploadTitle;
            document.getElementById('uploadSubtitle').textContent = currentTexts.uploadSubtitle;
            document.getElementById('settingsTitle').textContent = currentTexts.settingsTitle;
            document.getElementById('contrastLabel').textContent = currentTexts.contrastLabel;
            document.getElementById('sharpnessLabel').textContent = currentTexts.sharpnessLabel;
            document.getElementById('resetCropText').textContent = currentTexts.resetCropText;
            document.getElementById('previewText').textContent = currentTexts.previewText;
            document.getElementById('downloadText').textContent = currentTexts.downloadText;
            document.getElementById('batchText').textContent = currentTexts.batchText;
            document.getElementById('previewInfo').textContent = currentTexts.previewSelectImage;
        }

        function setupEventListeners() {
            // File input and drag & drop
            const fileInput = document.getElementById('fileInput');
            const uploadArea = document.getElementById('uploadArea');
            
            uploadArea.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);
            
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleDrop);
            
            // Canvas events for cropping
            canvas.addEventListener('mousedown', startCrop);
            canvas.addEventListener('mousemove', updateCrop);
            canvas.addEventListener('mouseup', endCrop);
            canvas.addEventListener('mouseleave', endCrop);
            
            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
            
            // Kindle device selection
            document.getElementById('kindleModel').addEventListener('change', updateKindleDevice);
            document.getElementById('customWidth').addEventListener('input', updateCustomSize);
            document.getElementById('customHeight').addEventListener('input', updateCustomSize);
            
            // Control sliders
            document.getElementById('contrastSlider').addEventListener('input', updateSliderValue);
            document.getElementById('sharpnessSlider').addEventListener('input', updateSliderValue);
            
            // Buttons
            document.getElementById('resetCropBtn').addEventListener('click', resetCrop);
            document.getElementById('previewBtn').addEventListener('click', generatePreview);
            document.getElementById('downloadBtn').addEventListener('click', downloadImage);
            document.getElementById('batchBtn').addEventListener('click', batchProcess);
        }

        function handleFileSelect(event) {
            const files = event.target.files;
            if (files.length > 0) {
                if (files.length === 1) {
                    loadImage(files[0]);
                } else {
                    // Multiple files selected - enable batch processing
                    enableBatchMode(files);
                }
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
            document.getElementById('uploadArea').classList.add('dragover');
        }

        function handleDragLeave() {
            document.getElementById('uploadArea').classList.remove('dragover');
        }

        function handleDrop(event) {
            event.preventDefault();
            document.getElementById('uploadArea').classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                if (files.length === 1) {
                    loadImage(files[0]);
                } else {
                    enableBatchMode(files);
                }
            }
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    displayImage();
                    updateStatus(currentTexts.statusImageLoaded);
                    enableButtons(true);
                };
                img.onerror = function() {
                    showToast(currentTexts.errorImageLoad, 'error');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function displayImage() {
            if (!originalImage) return;
            
            const maxCanvasWidth = 800;
            const maxCanvasHeight = 600;
            
            // Calculate display size maintaining aspect ratio
            let displayWidth = originalImage.width;
            let displayHeight = originalImage.height;
            
            if (displayWidth > maxCanvasWidth || displayHeight > maxCanvasHeight) {
                const widthRatio = maxCanvasWidth / displayWidth;
                const heightRatio = maxCanvasHeight / displayHeight;
                const ratio = Math.min(widthRatio, heightRatio);
                
                displayWidth = displayWidth * ratio;
                displayHeight = displayHeight * ratio;
            }
            
            canvas.width = displayWidth;
            canvas.height = displayHeight;
            
            // Calculate scale for crop calculations
            imageScale = Math.min(displayWidth / originalImage.width, displayHeight / originalImage.height);
            imageOffset = {
                x: (displayWidth - originalImage.width * imageScale) / 2,
                y: (displayHeight - originalImage.height * imageScale) / 2
            };
            
            // Draw image
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(originalImage, imageOffset.x, imageOffset.y, 
                         originalImage.width * imageScale, originalImage.height * imageScale);
            
            // Initialize default crop
            initializeDefaultCrop();
        }

        function initializeDefaultCrop() {
            const ratio = currentKindleSize.width / currentKindleSize.height;
            const imageDisplayWidth = originalImage.width * imageScale;
            const imageDisplayHeight = originalImage.height * imageScale;
            
            let cropWidth, cropHeight;
            
            if (imageDisplayWidth / imageDisplayHeight > ratio) {
                // Image is wider than Kindle ratio, fit by height
                cropHeight = imageDisplayHeight * 0.8;
                cropWidth = cropHeight * ratio;
            } else {
                // Image is taller than Kindle ratio, fit by width
                cropWidth = imageDisplayWidth * 0.8;
                cropHeight = cropWidth / ratio;
            }
            
            cropArea = {
                x: imageOffset.x + (imageDisplayWidth - cropWidth) / 2,
                y: imageOffset.y + (imageDisplayHeight - cropHeight) / 2,
                width: cropWidth,
                height: cropHeight
            };
            
            drawCropOverlay();
            updateCropInfo();
        }

        function startCrop(event) {
            if (!originalImage) return;
            
            const rect = canvas.getBoundingClientRect();
            startX = event.clientX - rect.left;
            startY = event.clientY - rect.top;
            isDragging = true;
        }

        function updateCrop(event) {
            if (!isDragging || !originalImage) return;
            
            const rect = canvas.getBoundingClientRect();
            const currentX = event.clientX - rect.left;
            const currentY = event.clientY - rect.top;
            
            updateCropArea(startX, startY, currentX, currentY);
        }

        function endCrop() {
            isDragging = false;
            if (cropArea.width > 10 && cropArea.height > 10) {
                updateStatus(currentTexts.statusCropSet);
            }
        }

        function handleTouchStart(event) {
            event.preventDefault();
            const touch = event.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }

        function handleTouchMove(event) {
            event.preventDefault();
            const touch = event.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }

        function handleTouchEnd(event) {
            event.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        }

        function updateCropArea(startX, startY, endX, endY) {
            const ratio = currentKindleSize.width / currentKindleSize.height;
            
            let width = Math.abs(endX - startX);
            let height = Math.abs(endY - startY);
            
            // Maintain Kindle aspect ratio
            if (width / height > ratio) {
                width = height * ratio;
            } else {
                height = width / ratio;
            }
            
            let x = Math.min(startX, endX);
            let y = Math.min(startY, endY);
            
            // Adjust position if dragging from different corners
            if (endX < startX) {
                x = startX - width;
            }
            if (endY < startY) {
                y = startY - height;
            }
            
            // Keep crop within image bounds
            const imageDisplayWidth = originalImage.width * imageScale;
            const imageDisplayHeight = originalImage.height * imageScale;
            
            x = Math.max(imageOffset.x, Math.min(x, imageOffset.x + imageDisplayWidth - width));
            y = Math.max(imageOffset.y, Math.min(y, imageOffset.y + imageDisplayHeight - height));
            
            cropArea = { x, y, width, height };
            
            drawCropOverlay();
            updateCropInfo();
        }

        function drawCropOverlay() {
            if (!originalImage) return;
            
            // Redraw image
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(originalImage, imageOffset.x, imageOffset.y, 
                         originalImage.width * imageScale, originalImage.height * imageScale);
            
            // Draw darkened overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Clear crop area
            ctx.clearRect(cropArea.x, cropArea.y, cropArea.width, cropArea.height);
            
            // Redraw image in crop area
            const cropImageX = (cropArea.x - imageOffset.x) / imageScale;
            const cropImageY = (cropArea.y - imageOffset.y) / imageScale;
            const cropImageWidth = cropArea.width / imageScale;
            const cropImageHeight = cropArea.height / imageScale;
            
            ctx.drawImage(originalImage, 
                         cropImageX, cropImageY, cropImageWidth, cropImageHeight,
                         cropArea.x, cropArea.y, cropArea.width, cropArea.height);
            
            // Draw crop border
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.strokeRect(cropArea.x, cropArea.y, cropArea.width, cropArea.height);
            
            // Draw corner handles
            const handleSize = 10;
            ctx.fillStyle = '#667eea';
            
            // Top-left
            ctx.fillRect(cropArea.x - handleSize/2, cropArea.y - handleSize/2, handleSize, handleSize);
            // Top-right
            ctx.fillRect(cropArea.x + cropArea.width - handleSize/2, cropArea.y - handleSize/2, handleSize, handleSize);
            // Bottom-left
            ctx.fillRect(cropArea.x - handleSize/2, cropArea.y + cropArea.height - handleSize/2, handleSize, handleSize);
            // Bottom-right
            ctx.fillRect(cropArea.x + cropArea.width - handleSize/2, cropArea.y + cropArea.height - handleSize/2, handleSize, handleSize);
        }

        function updateCropInfo() {
            const realCropWidth = Math.round(cropArea.width / imageScale);
            const realCropHeight = Math.round(cropArea.height / imageScale);
            const ratio = (realCropWidth / realCropHeight).toFixed(2);
            const kindleRatio = (currentKindleSize.width / currentKindleSize.height).toFixed(2);
            
            const cropDetails = `
                <strong>Crop Area:</strong> ${realCropWidth} √ó ${realCropHeight} px<br>
                <strong>Current Ratio:</strong> ${ratio}:1<br>
                <strong>Kindle Ratio:</strong> ${kindleRatio}:1<br>
                <strong>Target:</strong> ${currentKindleSize.width} √ó ${currentKindleSize.height} px
            `;
            
            document.getElementById('cropDetails').innerHTML = cropDetails;
            document.getElementById('cropInfo').style.display = 'block';
        }

        function updateKindleDevice() {
            const select = document.getElementById('kindleModel');
            const customInputs = document.getElementById('customSizeInputs');
            
            if (select.value === 'custom') {
                customInputs.style.display = 'flex';
                updateCustomSize();
            } else {
                customInputs.style.display = 'none';
                currentKindleSize = kindleDevices[select.value];
            }
            
            // Reinitialize crop if image is loaded
            if (originalImage) {
                initializeDefaultCrop();
            }
            
            // Update preview info
            updatePreviewInfo();
        }

        function updateCustomSize() {
            const width = parseInt(document.getElementById('customWidth').value);
            const height = parseInt(document.getElementById('customHeight').value);
            
            if (width > 0 && height > 0) {
                currentKindleSize = { 
                    width: width, 
                    height: height, 
                    name: `Custom ${width}√ó${height}` 
                };
                
                if (originalImage) {
                    initializeDefaultCrop();
                }
                updatePreviewInfo();
            }
        }

        function updateSliderValue(event) {
            const slider = event.target;
            const valueSpan = document.getElementById(slider.id.replace('Slider', 'Value'));
            valueSpan.textContent = parseFloat(slider.value).toFixed(1);
        }

        function resetCrop() {
            if (originalImage) {
                initializeDefaultCrop();
                updateStatus(currentTexts.statusReady);
            }
        }

        function generatePreview() {
            if (!originalImage) {
                showToast(currentTexts.errorImageLoad, 'error');
                return;
            }
            
            updateStatus(currentTexts.statusProcessing);
            
            setTimeout(() => {
                try {
                    const processedImage = processImageForKindle();
                    
                    // Display in preview canvas
                    const maxPreviewSize = 250;
                    const scale = Math.min(maxPreviewSize / currentKindleSize.width, 
                                         maxPreviewSize / currentKindleSize.height);
                    
                    previewCanvas.width = currentKindleSize.width * scale;
                    previewCanvas.height = currentKindleSize.height * scale;
                    
                    previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                    previewCtx.drawImage(processedImage, 0, 0, previewCanvas.width, previewCanvas.height);
                    
                    updatePreviewInfo();
                    updateStatus(currentTexts.statusPreviewReady);
                    
                    document.getElementById('downloadBtn').disabled = false;
                } catch (error) {
                    showToast(currentTexts.errorImageProcess, 'error');
                    updateStatus(currentTexts.statusReady);
                }
            }, 100);
        }

        function processImageForKindle() {
            // Create a temporary canvas for processing
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // Calculate crop area in original image coordinates
            const cropX = (cropArea.x - imageOffset.x) / imageScale;
            const cropY = (cropArea.y - imageOffset.y) / imageScale;
            const cropWidth = cropArea.width / imageScale;
            const cropHeight = cropArea.height / imageScale;
            
            // Set canvas to Kindle dimensions
            tempCanvas.width = currentKindleSize.width;
            tempCanvas.height = currentKindleSize.height;
            
            // Draw cropped and resized image
            tempCtx.drawImage(originalImage, 
                             cropX, cropY, cropWidth, cropHeight,
                             0, 0, currentKindleSize.width, currentKindleSize.height);
            
            // Convert to grayscale and apply enhancements
            const imageData = tempCtx.getImageData(0, 0, currentKindleSize.width, currentKindleSize.height);
            const data = imageData.data;
            
            const contrast = parseFloat(document.getElementById('contrastSlider').value);
            const sharpness = parseFloat(document.getElementById('sharpnessSlider').value);
            
            // Apply grayscale conversion and enhancements
            for (let i = 0; i < data.length; i += 4) {
                // Convert to grayscale using luminance formula
                const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                
                // Apply contrast
                let adjustedGray = ((gray / 255 - 0.5) * contrast + 0.5) * 255;
                adjustedGray = Math.max(0, Math.min(255, adjustedGray));
                
                // Set RGB channels to the same value for grayscale
                data[i] = adjustedGray;     // R
                data[i + 1] = adjustedGray; // G
                data[i + 2] = adjustedGray; // B
                // Alpha channel stays the same
            }
            
            tempCtx.putImageData(imageData, 0, 0);
            
            return tempCanvas;
        }

        function updatePreviewInfo() {
            const info = `${currentKindleSize.width} √ó ${currentKindleSize.height} ${currentTexts.previewDimensions}<br>
                         ${(currentKindleSize.width / currentKindleSize.height).toFixed(2)}:1 ${currentTexts.previewRatio}`;
            document.getElementById('previewInfo').innerHTML = info;
        }

        function downloadImage() {
            if (!originalImage) {
                showToast(currentTexts.errorImageLoad, 'error');
                return;
            }
            
            try {
                const processedCanvas = processImageForKindle();
                
                // Create download link
                processedCanvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `kindle_screensaver_${currentKindleSize.width}x${currentKindleSize.height}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showToast(currentTexts.successMessage, 'success');
                }, 'image/png', 1.0);
                
            } catch (error) {
                showToast(currentTexts.errorImageProcess, 'error');
            }
        }

        function batchProcess() {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;
            input.accept = 'image/*';
            
            input.addEventListener('change', (event) => {
                const files = Array.from(event.target.files);
                if (files.length > 0) {
                    processBatch(files);
                }
            });
            
            input.click();
        }

        function enableBatchMode(files) {
            processBatch(Array.from(files));
        }

        async function processBatch(files) {
            updateStatus(`${currentTexts.batchProcessing} (0/${files.length})`);
            
            let processed = 0;
            const results = [];
            
            for (const file of files) {
                try {
                    const result = await processFileForBatch(file);
                    if (result) {
                        results.push(result);
                    }
                } catch (error) {
                    console.error('Error processing file:', file.name, error);
                }
                
                processed++;
                updateStatus(`${currentTexts.batchProcessing} (${processed}/${files.length})`);
            }
            
            // Download all processed images as a ZIP would require additional library
            // For now, download them one by one
            for (const result of results) {
                const a = document.createElement('a');
                a.href = result.url;
                a.download = result.filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(result.url);
            }
            
            updateStatus(`${currentTexts.batchComplete} ${results.length}/${files.length}`);
            showToast(`${currentTexts.batchComplete} ${results.length} images`, 'success');
        }

        function processFileForBatch(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        try {
                            // Auto-crop to center with Kindle proportions
                            const kindleRatio = currentKindleSize.width / currentKindleSize.height;
                            const imageRatio = img.width / img.height;
                            
                            let cropX, cropY, cropWidth, cropHeight;
                            
                            if (imageRatio > kindleRatio) {
                                // Image is wider, crop horizontally
                                cropHeight = img.height;
                                cropWidth = cropHeight * kindleRatio;
                                cropX = (img.width - cropWidth) / 2;
                                cropY = 0;
                            } else {
                                // Image is taller, crop vertically
                                cropWidth = img.width;
                                cropHeight = cropWidth / kindleRatio;
                                cropX = 0;
                                cropY = (img.height - cropHeight) / 2;
                            }
                            
                            // Process image
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCanvas.width = currentKindleSize.width;
                            tempCanvas.height = currentKindleSize.height;
                            
                            tempCtx.drawImage(img, 
                                             cropX, cropY, cropWidth, cropHeight,
                                             0, 0, currentKindleSize.width, currentKindleSize.height);
                            
                            // Apply grayscale and enhancements
                            const imageData = tempCtx.getImageData(0, 0, currentKindleSize.width, currentKindleSize.height);
                            const data = imageData.data;
                            
                            const contrast = parseFloat(document.getElementById('contrastSlider').value);
                            
                            for (let i = 0; i < data.length; i += 4) {
                                const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                                let adjustedGray = ((gray / 255 - 0.5) * contrast + 0.5) * 255;
                                adjustedGray = Math.max(0, Math.min(255, adjustedGray));
                                
                                data[i] = adjustedGray;
                                data[i + 1] = adjustedGray;
                                data[i + 2] = adjustedGray;
                            }
                            
                            tempCtx.putImageData(imageData, 0, 0);
                            
                            tempCanvas.toBlob((blob) => {
                                const url = URL.createObjectURL(blob);
                                const filename = `${file.name.split('.')[0]}_kindle_${currentKindleSize.width}x${currentKindleSize.height}.png`;
                                resolve({ url, filename });
                            }, 'image/png');
                            
                        } catch (error) {
                            resolve(null);
                        }
                    };
                    img.onerror = () => resolve(null);
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        function enableButtons(enabled) {
            document.getElementById('resetCropBtn').disabled = !enabled;
            document.getElementById('previewBtn').disabled = !enabled;
            document.getElementById('batchBtn').disabled = !enabled;
        }

        function updateStatus(message) {
            document.getElementById('statusBar').textContent = message;
        }

        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.classList.add('show');
            }, 100);
            
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(toast);
                }, 300);
            }, 3000);
        }

        // Initialize application when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>